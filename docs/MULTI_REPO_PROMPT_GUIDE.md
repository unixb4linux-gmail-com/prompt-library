# Multi-Repository Prompt Management Best Practices Guide

This guide outlines best practices for managing a centralized prompt library across multiple repositories, leveraging symlinks and custom tooling for efficiency, consistency, and maintainability.

## 1. Centralized Prompt Library Structure

Maintain a single, version-controlled repository for all your prompts and rules. This repository should have a clear, hierarchical structure for categorization and easy navigation.

### Recommended Structure:

```
prompt-library/
├── .github/prompts/          # Claude Code prompts
│   ├── category-a/
│   │   └── prompt-a.prompt.md
│   └── category-b/
│       └── prompt-b.prompt.md
├── .rules/                   # Gemini CLI rules
│   ├── category-x/
│   │   └── rule-x.mdc
│   └── category-y/
│       └── rule-y.mdc
├── aiops/
├── mlops/
├── generic/
├── templates/                # Boilerplate for new prompts
│   └── prompt_template.md
├── scripts/                  # Automation scripts (symlink management, indexing, CLI)
│   ├── manage_symlinks.py
│   ├── generate_index.py
│   └── prompt_cli.py
├── docs/                     # Documentation (this guide, metadata schema, etc.)
│   └── MULTI_REPO_PROMPT_GUIDE.md
├── symlink_config.json       # Configuration for symlink automation
└── PROMPT_RULE_INDEX.md      # Auto-generated index of all prompts
```

### Metadata Schema (YAML Frontmatter)

Each prompt/rule file should include YAML frontmatter with the following standardized metadata:

```yaml
id: unique-prompt-identifier
name: Human-readable Prompt Name
description: A concise summary of the prompt's purpose.
version: 0.1.0
created_date: YYYY-MM-DD
last_updated: YYYY-MM-DD
tags: ["tag1", "tag2"]
tool_compatibility: ["claude-code", "gemini-cli"]
dependencies: [] # List of other prompt IDs this prompt depends on
parameters: [] # Schema for expected input parameters
output_format: markdown # Expected output format (e.g., markdown, json, yaml)
```

## 2. Symlink Management Automation

Utilize the `scripts/manage_symlinks.py` tool to automate the creation, validation, and updating of symlinks from your project repositories to the central prompt library.

### `symlink_config.json`

Define which prompts/rules should be symlinked to which repositories in `symlink_config.json`:

```json
{
  "repositories": [
    {
      "path": "/path/to/your/project-repo-1",
      "symlinks": {
        ".github/prompts": [
          "analyze_aks.prompt.md",
          "build_aks.prompt.md"
        ],
        ".rules": [
          "analyze-codebase.mdc",
          "*" # Use wildcard to link all rules in .rules/
        ]
      }
    },
    {
      "path": "/path/to/your/project-repo-2",
      "symlinks": {
        ".github/prompts": ["*"],
        ".rules": ["nextjs-app-router.mdc"]
      }
    }
  ]
}
```

### Usage of `manage_symlinks.py`

*   **Create/Update Symlinks**: 
    `python3 scripts/manage_symlinks.py --config symlink_config.json --root . create [--force]`
*   **Validate Symlinks**: 
    `python3 scripts/manage_symlinks.py --config symlink_config.json --root . validate`
*   **Force Update (recreate)**: 
    `python3 scripts/manage_symlinks.py --config symlink_config.json --root . update`

## 3. Prompt Quality & Consistency

### Prompt Template

Always start new prompts using the `templates/prompt_template.md` to ensure consistent structure and metadata. The template provides sections for:

*   **Purpose**: What problem does this prompt solve?
*   **Context**: What information does the AI need?
*   **Task**: What should the AI do?
*   **Output Format**: How should the AI present its response?
*   **Examples**: Few-shot examples if applicable.

### Parameter Handling

Use a consistent placeholder syntax within prompts (e.g., `{{parameter_name}}`) for variable substitution. Document these parameters in the `parameters` field of the YAML frontmatter.

### Linting

Regularly run the linting command to ensure all prompts adhere to the defined metadata schema and best practices:

`python3 scripts/prompt_cli.py lint`

## 4. Tooling for Discovery and Maintenance

### Prompt CLI (`scripts/prompt_cli.py`)

*   **Search**: Find prompts by keyword, tag, or tool compatibility.
    `python3 scripts/prompt_cli.py search <keyword> [--tag <tag>] [--tool <tool>]`
*   **Show**: Display the content and metadata of a specific prompt.
    `python3 scripts/prompt_cli.py show <prompt_id>`

### Prompt Index (`PROMPT_RULE_INDEX.md`)

This file is automatically generated by `scripts/generate_index.py` and provides a comprehensive, searchable catalog of all prompts and rules in the library. It includes key metadata for quick discovery.

## 5. Version Control and Collaboration

*   **Git Workflow**: Use standard Git workflows (branches, pull requests, code reviews) for all changes to the prompt library.
*   **Semantic Versioning**: Adhere to Semantic Versioning (SemVer) for prompt versions. Increment MAJOR for breaking changes, MINOR for new features, and PATCH for bug fixes.
*   **Automated Versioning**: Utilize `scripts/version_prompts.py` to manage version information in the YAML frontmatter.

## 6. Onboarding New Repositories

1.  **Add Repository to `symlink_config.json`**: Define the repository path and the specific prompts/rules to be symlinked.
2.  **Run `manage_symlinks.py create`**: Execute the script to create the initial symlinks.
3.  **Validate**: Run `manage_symlinks.py validate` to ensure all symlinks are correctly established.

## 7. Managing Breaking Changes

When a prompt undergoes a breaking change (e.g., changes in parameters, output format, or core logic), follow these steps:

1.  **Increment MAJOR Version**: Update the `version` in the YAML frontmatter (e.g., `1.0.0` to `2.0.0`).
2.  **Update Documentation**: Clearly document the breaking changes and migration steps in the prompt's description or a linked `README.md`.
3.  **Communicate**: Inform all dependent projects/teams about the breaking change and provide guidance for updating their usage.
4.  **Provide Migration Path**: If feasible, offer a temporary compatibility layer or a clear migration script.
